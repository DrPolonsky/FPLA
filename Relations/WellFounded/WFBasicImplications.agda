open import Logic
open import Predicates
open import Relations.Core
open import Datatypes
open import Classical
open import Relations.Decidable
open import Relations.ClosureOperators
open import Relations.Seq
-- TODO: Remove unused imports
module Relations.WellFounded.WFBasicImplications where

open import Relations.WellFounded.WFDefinitions public
open import Relations.WellFounded.WFWeakDefinitions public

module BasicImplications {A : Set} {R : ð“¡ A} where

  -- Accessibility is the least inductive predicate
  accâŠ†ind : âˆ€ (Ï† : ð“Ÿ A) â†’ R -inductive Ï† â†’ R -accessible âŠ† Ï†
  accâŠ†ind Ï† Ï†isRind x (acc IH) = Ï†isRind x (Î» y Ryx â†’ accâŠ†ind Ï† Ï†isRind y (IH y Ryx) )

  -- accâŠ†WFseq : R -accessible âŠ† WFseq R
  -- accâŠ†WFseq a (acc ac) s s0=a = accâŠ†WFseq (s 1) {!   !} {!   !} {!   !}
  --
  Â¬acc : âˆ€ {x : A} â†’ x âˆ‰ R -accessible â†’ Â¬ (âˆ€ y â†’ R y x â†’ y âˆˆ R -accessible)
  Â¬acc Â¬xisRacc âˆ€yisRacc = Â¬xisRacc (acc âˆ€yisRacc)

  Â¬ind : âˆ€ (P : ð“Ÿ A) â†’ R -inductive P â†’ âˆ€ x â†’ Â¬ (P x) â†’ Â¬ (âˆ€ y â†’ R y x â†’ P y)
  Â¬ind P Pind x Â¬Px âˆ€y = Â¬Px (Pind x âˆ€y )

  wfâ†’irrefl : R isWF â†’ âˆ€ x â†’ Â¬ R x x
  wfâ†’irrefl RisWF x = go x (RisWF x) where
    go : âˆ€ y â†’ y âˆˆ R -accessible â†’ Â¬ R y y
    go y (acc Hy) Ryy = go y (Hy y Ryy) Ryy

  -- implications between the base definitions
  isWFaccâ†’isWFind : R isWFacc â†’ R isWFind
  isWFaccâ†’isWFind wfAcc x Ï† Ï†-ind = accâŠ†ind Ï† Ï†-ind x (wfAcc x)

  isWFindâ†’isWFacc : R isWFind â†’ R isWFacc
  isWFindâ†’isWFacc wfInd x = wfInd x (WFacc R ) Î» y â†’ acc

  isWFminâ†’isWFminDNE : R isWFmin â†’ R isWFminDNE
  isWFminâ†’isWFminDNE RisWFmin P PDNE = RisWFmin P

  isWFminDNEâ†’isWFminEM : R isWFminDNE â†’ R isWFminEM
  isWFminDNEâ†’isWFminEM RisWFminDNE P PEM = RisWFminDNE P (decâ†’Â¬Â¬Closed P PEM )

  isWFminâ†’isWFseq : R isWFmin â†’ R isWFseq
  isWFminâ†’isWFseq wfMin s with wfMin (Î» a â†’ Î£[ n âˆˆ â„• ] (s n â‰¡ a)) (s zero) (zero ,, refl)
  ... | x ,, (k ,, p) , H = (k ,, Î» Ryx â†’ H (s (succ k)) (succ k ,, refl ) (transp (R (s (succ k))) p Ryx ) )

  WFseq+âŠ†WFseq : WFseq+ R âŠ† WFseq R
  WFseq+âŠ†WFseq x xâˆˆseq+ s s0â‰¡x with xâˆˆseq+ s s0â‰¡x
  ... | k ,, n  = k ,, n

  -- WFseqâŠ†WFseq+ : WFseq R âŠ† WFseq+ R
  -- WFseqâŠ†WFseq+ x xâˆˆseq s s0â‰¡x with xâˆˆseq s s0â‰¡x
  -- ... | k ,, n = k ,, {!   !}

  {- This formulation of WFseq+ is wrong:
  Consider ARS a -> b.
  Consider the sequence s(k) = a.
  Then s(k) is not a normal form, and the sequence s does not contain a normal form.
  Yet every sequence in this ARS does contain an element not reducing to its successor.

  Say that s : â„• â†’ A is *almost increasing* if for all n,
  either s(n) -> s(n+1) or s(n) is a normal form.

  WFseq+ could be something like: "every almost increasing sequence ends in a normal form".
  (IE, âˆ€ s : â„• â†’ A, AlmostIncreasing(s) â†’ Î£[ n âˆˆ â„• ] (s n âˆˆ NF ).)

  Let's check that such WFseq+ would indeed be equivalent to WFseq.
  1. WFseqâŠ†WFseq+. Assume WFseq.  Let s be given, suppose s is almost increasing.
  By assumption, exists k s.t. s(k) does not reduce to s(k+1).
  Since s is almost increasing, s(k) must be a normal form.
  2. WFseq+âŠ†WFseq.
  (That is, if every almost increasing sequence contains/ends in a normal form,
  then every sequence contains an element not reducing to its successor.)
  Classical argument.  Assume WFseq+.
  Let s be a sequence.
  By excluded middle, either s is almost increasing, or
  there exists an n, such that s(n) is neither a normal form, nor s(n) -> s(n+1).
  This n yields an index on which s does not reduce to its successor.
-}

open BasicImplications
